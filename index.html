<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Platonic Solids & Symmetry Ops</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: rgba(25, 25, 30, 0.9);
            --text-color: #e0e0e0;
            --accent-color: #4facfe;
            --accent-hover: #00f2fe;
            --highlight: #ff0055;
            --ghost-color: #00ff88;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        /* UI Panels */
        .panel {
            position: absolute;
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.6);
            z-index: 10;
            transition: all 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }

        #controls {
            top: 20px;
            left: 20px;
            width: 300px;
        }

        #info {
            top: 20px;
            right: 20px;
            width: 320px;
        }

        h2, h3 {
            margin-top: 0;
            font-weight: 400;
            letter-spacing: 1px;
            color: var(--accent-color);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        /* Tabs */
        .mode-tabs {
            display: flex;
            margin-bottom: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 4px;
        }
        .mode-tab {
            flex: 1;
            text-align: center;
            padding: 8px;
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.85rem;
            transition: background 0.2s;
            color: #888;
        }
        .mode-tab.active {
            background: var(--accent-color);
            color: #fff;
            font-weight: bold;
        }

        /* Form Elements */
        label {
            display: block;
            margin-bottom: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        select {
            width: 100%;
            padding: 8px;
            background: rgba(0,0,0,0.4);
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            margin-bottom: 12px;
            font-size: 0.9rem;
            outline: none;
        }

        .slider-container {
            margin-bottom: 15px;
        }
        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #aaa;
        }
        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent-color);
        }

        .toggle-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        input[type="checkbox"] {
            accent-color: var(--accent-color);
            transform: scale(1.2);
            cursor: pointer;
        }

        /* Data Display */
        .data-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .data-item {
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }
        .data-val { display: block; font-size: 1.2rem; font-weight: bold; color: var(--accent-hover); }
        .data-label { font-size: 0.7rem; opacity: 0.7; text-transform: uppercase; }

        /* Dynamic Panels */
        .control-panel { display: none; }
        .control-panel.active { display: block; animation: fadeIn 0.3s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* Legend */
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }
        .color-dot { width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; }

        /* Button */
        .btn {
            width: 100%;
            padding: 10px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: 0.2s;
        }
        .btn:hover { background: #444; }

        /* Specific Visualization Hints */
        .hint { font-size: 0.8rem; color: var(--accent-hover); font-style: italic; margin-top: 5px; }

        @media (max-width: 768px) {
            #controls { top: auto; bottom: 10px; left: 10px; right: 10px; width: auto; max-height: 40vh; }
            #info { top: 10px; left: 10px; right: 10px; max-height: 40vh; width: auto; }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="controls" class="panel">
        <h2>Visualization</h2>
        
        <div class="mode-tabs">
            <div class="mode-tab active" data-target="solid">Solids</div>
            <div class="mode-tab" data-target="proof">Proof</div>
            <div class="mode-tab" data-target="ops">Sym Ops</div>
        </div>

        <!-- SOLID MODE CONTROLS -->
        <div id="panel-solid" class="control-panel active">
            <label for="shapeSelect">Select Solid:</label>
            <select id="shapeSelect">
                <option value="tetrahedron">Tetrahedron</option>
                <option value="cube" selected>Cube</option>
                <option value="octahedron">Octahedron</option>
                <option value="dodecahedron">Dodecahedron</option>
                <option value="icosahedron">Icosahedron</option>
            </select>

            <div class="toggle-group">
                <div class="checkbox-wrapper"><label>Solid Faces</label><input type="checkbox" id="showFaces" checked></div>
                <div class="checkbox-wrapper"><label>Wireframe</label><input type="checkbox" id="showWireframe" checked></div>
                <div class="checkbox-wrapper"><label>Vertices</label><input type="checkbox" id="showVertices" checked></div>
                <div class="checkbox-wrapper"><label>Show Symmetry Axes</label><input type="checkbox" id="showAxes"></div>
            </div>
            <div class="toggle-group">
                <div class="checkbox-wrapper"><label>Auto Rotate</label><input type="checkbox" id="autoRotate" checked></div>
            </div>
        </div>

        <!-- PROOF MODE CONTROLS -->
        <div id="panel-proof" class="control-panel">
            <h3>Angle Sum Limit</h3>
            <label>Number of Triangles (n): <span id="proofVal">3</span></label>
            <div class="slider-container">
                <input type="range" id="proofSlider" min="3" max="6" step="1" value="3">
            </div>
            <div class="hint">Slide to 6 to see the flat plane (360°).<br>Proves no 6-fold symmetry exists.</div>
            <button class="btn" onclick="resetProof()">Reset</button>
        </div>

        <!-- OPERATIONS MODE CONTROLS -->
        <div id="panel-ops" class="control-panel">
            <label for="opSelect">Operation Type:</label>
            <select id="opSelect">
                <option value="rotate">Rotation (C<sub>n</sub>)</option>
                <option value="reflect">Reflection (&sigma;)</option>
                <option value="invert">Inversion (i)</option>
            </select>

            <!-- Rotation Controls -->
            <div id="ctrl-rotate">
                <label for="rotAxisSelect">Select Axis:</label>
                <select id="rotAxisSelect">
                    <!-- Populated via JS -->
                </select>
                
                <div class="slider-container">
                    <div class="slider-header"><span>Angle</span><span id="rotAngleVal">0°</span></div>
                    <input type="range" id="rotAngle" min="0" max="360" step="1" value="0">
                </div>
                <button class="btn" id="animRotateBtn">Animate 360°</button>
            </div>

            <!-- Reflection Controls -->
            <div id="ctrl-reflect" style="display:none;">
                <label for="refPlaneSelect">Select Plane:</label>
                <select id="refPlaneSelect">
                    <!-- Populated via JS -->
                </select>
                
                <div class="slider-container">
                    <div class="slider-header"><span>Reflection Progress</span><span id="refProgressVal">0%</span></div>
                    <input type="range" id="refProgress" min="0" max="100" step="1" value="0">
                </div>
                <div class="hint">Drag to slide ghost through mirror.</div>
            </div>

            <!-- Inversion Controls -->
            <div id="ctrl-invert" style="display:none;">
                <div class="slider-container">
                    <div class="slider-header"><span>Inversion Progress</span><span id="invProgressVal">0%</span></div>
                    <input type="range" id="invProgress" min="0" max="100" step="1" value="0">
                </div>
                <div class="hint">Drag to move ghost through origin (x,y,z -> -x,-y,-z).</div>
            </div>
        </div>
    </div>

    <div id="info" class="panel">
        <h2 id="infoTitle">Cube</h2>
        
        <div id="info-solid" class="control-panel active">
            <div class="data-grid">
                <div class="data-item"><span class="data-val" id="valFaces">6</span><span class="data-label">Faces</span></div>
                <div class="data-item"><span class="data-val" id="valVertices">8</span><span class="data-label">Vertices</span></div>
                <div class="data-item"><span class="data-val" id="valEdges">12</span><span class="data-label">Edges</span></div>
                <div class="data-item"><span class="data-val" id="valAxes">0</span><span class="data-label">Axes</span></div>
            </div>
            <div id="eulerDisplay" style="font-size: 0.85rem; color:#888;"></div>
            <br>
            <h3>Legend</h3>
            <div class="legend-item"><div class="color-dot" style="background:yellow"></div> <span>Fourfold Axis</span></div>
            <div class="legend-item"><div class="color-dot" style="background:magenta"></div> <span>Threefold Axis</span></div>
            <div class="legend-item"><div class="color-dot" style="background:cyan"></div> <span>Twofold Axis</span></div>
            <div class="legend-item"><div class="color-dot" style="background:#0f0"></div> <span>Fivefold Axis</span></div>
        </div>

        <div id="info-proof" class="control-panel">
            <div class="data-grid">
                <div class="data-item"><span class="data-val" id="proofAngle">180°</span><span class="data-label">Angle Sum</span></div>
                <div class="data-item"><span class="data-val" id="proofHeight">0.81</span><span class="data-label">Height</span></div>
            </div>
            <div id="proofStatusBox" style="text-align: center; padding: 10px; border: 1px solid #555; border-radius: 6px;">
                Status: <span id="proofStatus">VALID</span>
            </div>
        </div>

        <div id="info-ops" class="control-panel">
            <div id="op-description" style="font-size: 0.9rem; line-height: 1.5; color: #ccc;">
                Select an operation to begin.
            </div>
            <hr style="border-color: #444;">
            <div class="legend-item"><div class="color-dot" style="background:var(--ghost-color)"></div> <span>Ghost (Result)</span></div>
            <div class="legend-item"><div class="color-dot" style="background:cyan; opacity:0.5"></div> <span>Mirror Plane</span></div>
            <div class="legend-item"><div class="color-dot" style="background:yellow; opacity:0.5"></div> <span>Rotation Arc</span></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Global State ---
        const state = {
            mode: 'solid', // solid, proof, ops
            shape: 'cube',
            
            // Visualization Toggles
            faces: true,
            wireframe: true,
            vertices: true,
            axes: false,
            autoRotate: true,

            // Proof Mode
            proofN: 3,

            // Ops Mode
            opType: 'rotate',
            rotAxis: null, // Vector3
            rotAngle: 0,
            rotOrder: 0,
            
            refPlaneNormal: null, // Vector3
            refProgress: 0,
            
            invProgress: 0
        };

        const metadata = {
            tetrahedron: { name: "Tetrahedron", f: 4, v: 4, e: 6 },
            cube: { name: "Cube", f: 6, v: 8, e: 12 },
            octahedron: { name: "Octahedron", f: 8, v: 6, e: 12 },
            dodecahedron: { name: "Dodecahedron", f: 12, v: 20, e: 30 },
            icosahedron: { name: "Icosahedron", f: 20, v: 12, e: 30 }
        };

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x121212);
        scene.fog = new THREE.FogExp2(0x121212, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(5, 4, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);
        const pointLight = new THREE.PointLight(0x4facfe, 0.5);
        pointLight.position.set(-5, -5, -5);
        scene.add(pointLight);

        // --- Object Groups ---
        const mainGroup = new THREE.Group(); // Holds the primary shape
        scene.add(mainGroup);

        const staticAxesGroup = new THREE.Group(); // Holds symmetry axes lines
        scene.add(staticAxesGroup);

        // Operation Visualization Objects
        const ghostGroup = new THREE.Group(); // The clone that moves
        scene.add(ghostGroup);
        
        const mirrorPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(6, 6),
            new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide, transparent: true, opacity: 0 })
        );
        scene.add(mirrorPlane);

        const rotationArc = new THREE.Group();
        scene.add(rotationArc);

        // Materials
        const matSolid = new THREE.MeshPhysicalMaterial({
            color: 0x4facfe, metalness: 0.1, roughness: 0.2, transmission: 0.6, opacity: 0.8, transparent: true, side: THREE.DoubleSide
        });
        const matGhost = new THREE.MeshBasicMaterial({ color: 0x00ff88, wireframe: true, transparent: true, opacity: 0.5 });
        const matEdge = new THREE.LineBasicMaterial({ color: 0xaaccff, transparent: true, opacity: 0.4 });
        const matVert = new THREE.PointsMaterial({ color: 0xff0055, size: 0.08, sizeAttenuation: true });
        const matGhostVert = new THREE.PointsMaterial({ color: 0x00ff88, size: 0.08, sizeAttenuation: true });

        // --- Core Geometry Logic ---
        function createGeometry(type) {
            switch(type) {
                case 'tetrahedron': return new THREE.TetrahedronGeometry(1.5);
                case 'cube': return new THREE.BoxGeometry(2, 2, 2);
                case 'octahedron': return new THREE.OctahedronGeometry(1.5);
                case 'dodecahedron': return new THREE.DodecahedronGeometry(1.5);
                case 'icosahedron': return new THREE.IcosahedronGeometry(1.5);
                default: return new THREE.BoxGeometry(1,1,1);
            }
        }

        function getUniqueVertices(geo) {
            const pos = geo.attributes.position;
            const unique = [];
            const set = new Set();
            for(let i=0; i<pos.count; i++){
                const k = `${pos.getX(i).toFixed(2)},${pos.getY(i).toFixed(2)},${pos.getZ(i).toFixed(2)}`;
                if(!set.has(k)) { set.add(k); unique.push(new THREE.Vector3(pos.getX(i), pos.getY(i), pos.getZ(i))); }
            }
            return unique;
        }

        // --- Symmetry Analysis ---
        function getSymmetryAxes(geo, uniqueVerts) {
            const axes = [];
            // Vertices
            uniqueVerts.forEach(v => { axes.push({vec: v.clone().normalize(), type: 'vertex'}); });
            // Faces (Normals)
            const ni = geo.clone().toNonIndexed().attributes.position;
            const normals = [];
            for(let i=0; i<ni.count; i+=3) {
                const a = new THREE.Vector3().fromBufferAttribute(ni, i);
                const b = new THREE.Vector3().fromBufferAttribute(ni, i+1);
                const c = new THREE.Vector3().fromBufferAttribute(ni, i+2);
                const n = new THREE.Vector3().crossVectors(new THREE.Vector3().subVectors(c,b), new THREE.Vector3().subVectors(a,b)).normalize();
                if(!normals.some(x=>x.distanceTo(n)<0.01)) { normals.push(n); normals.push(n.clone().negate()); }
            }
            normals.forEach(n => { axes.push({vec: n, type: 'face'}); });
            // Edges (Midpoints)
            const edgeGeo = new THREE.EdgesGeometry(geo);
            const ep = edgeGeo.attributes.position;
            const mids = [];
            for(let i=0; i<ep.count; i+=2) {
                const m = new THREE.Vector3().addVectors(new THREE.Vector3().fromBufferAttribute(ep,i), new THREE.Vector3().fromBufferAttribute(ep,i+1)).multiplyScalar(0.5).normalize();
                if(!mids.some(x=>x.distanceTo(m)<0.01)) { mids.push(m); mids.push(m.clone().negate()); }
            }
            mids.forEach(m => { axes.push({vec: m, type: 'edge'}); });

            // Clean up duplicates roughly
            const cleanAxes = [];
            axes.forEach(a => {
                if(!cleanAxes.some(c => c.vec.distanceTo(a.vec) < 0.01)) cleanAxes.push(a);
            });
            return cleanAxes;
        }

        function getSymmetryPlanes(geo, axes) {
            // Strategy: Planes usually correspond to Face Normals (for parallel planes) 
            // OR Edge Midpoints (for diagonal planes in cubic, etc).
            // Let's generate candidates from Face Normals and Edge Midpoints.
            
            const planes = []; // { normal: Vector3, type: string }
            const normals = new Set();

            // 1. Planes parallel to faces -> Normal is Face Normal
            axes.filter(a => a.type === 'face').forEach(a => {
                const key = `${a.vec.x.toFixed(2)},${a.vec.y.toFixed(2)},${a.vec.z.toFixed(2)}`;
                if(!normals.has(key)) { normals.add(key); planes.push({vec: a.vec, label: "Parallel to Face"}); }
            });

            // 2. Planes passing through edges -> Normal is Edge Midpoint vector (Perpendicular to edge bisector)
            axes.filter(a => a.type === 'edge').forEach(a => {
                const key = `${a.vec.x.toFixed(2)},${a.vec.y.toFixed(2)},${a.vec.z.toFixed(2)}`;
                if(!normals.has(key)) { normals.add(key); planes.push({vec: a.vec, label: "Diagonal"}); }
            });

            return planes;
        }

        // --- Scene Updating ---
        function updateScene() {
            // Clear existing
            mainGroup.clear();
            staticAxesGroup.clear();
            ghostGroup.clear();
            rotationArc.clear();
            mirrorPlane.material.opacity = 0;

            // 1. Build Geometry based on Mode
            if(state.mode === 'proof') {
                // Create the pyramid proof
                buildProof();
            } else {
                // Create standard solid
                const geo = createGeometry(state.shape);
                
                // Main Mesh
                const mesh = new THREE.Mesh(geo, matSolid);
                mesh.visible = state.faces;
                mainGroup.add(mesh);

                // Wireframe
                if(state.wireframe) {
                    const wire = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true, opacity:0.1, transparent:true}));
                    mainGroup.add(wire);
                    const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geo), matEdge);
                    mainGroup.add(edges);
                }

                // Vertices
                if(state.vertices) {
                    const verts = getUniqueVertices(geo);
                    mainGroup.add(new THREE.Points(new THREE.BufferGeometry().setFromPoints(verts), matVert));
                }

                // Symmetry Axes (Only in Solid mode for clarity)
                if(state.mode === 'solid' && state.axes) {
                    const uniqueVerts = getUniqueVertices(geo);
                    const axes = getSymmetryAxes(geo, uniqueVerts);
                    drawAxes(axes);
                }

                // Operations Mode Setup
                if(state.mode === 'ops') {
                    const uniqueVerts = getUniqueVertices(geo);
                    const axes = getSymmetryAxes(geo, uniqueVerts);
                    setupOps(geo, axes);
                }

                // Update UI Info
                const meta = metadata[state.shape];
                document.getElementById('infoTitle').innerText = meta.name;
                document.getElementById('valFaces').innerText = meta.f;
                document.getElementById('valVertices').innerText = meta.v;
                document.getElementById('valEdges').innerText = meta.e;
                document.getElementById('eulerDisplay').innerText = `Euler: ${meta.v} - ${meta.e} + ${meta.f} = 2`;
            }
        }

        function buildProof() {
            const n = state.proofN;
            const s = 1.0;
            const R = s / (2 * Math.sin(Math.PI / n));
            let h = Math.sqrt(s*s - R*R);
            if(isNaN(h)) h = 0;

            const p1 = new THREE.Vector3(0, h, 0);
            const color = n===6 ? 0xff0055 : 0x4facfe;
            const mat = new THREE.MeshPhysicalMaterial({color, metalness:0.1, roughness:0.2, side:THREE.DoubleSide});
            
            for(let i=0; i<n; i++){
                const a = (i*2*Math.PI)/n;
                const na = ((i+1)*2*Math.PI)/n;
                const vA = new THREE.Vector3(R*Math.cos(a), 0, R*Math.sin(a));
                const vB = new THREE.Vector3(R*Math.cos(na), 0, R*Math.sin(na));
                const tri = new THREE.Mesh(new THREE.BufferGeometry().setFromPoints([p1, vA, vB]), mat);
                mainGroup.add(tri);
                mainGroup.add(new THREE.LineSegments(new THREE.EdgesGeometry(tri.geometry), matEdge));
            }
            mainGroup.add(new THREE.Mesh(new THREE.RingGeometry(R-0.02, R+0.02, 64), new THREE.MeshBasicMaterial({color:0xffffff, side:THREE.DoubleSide, opacity:0.3, transparent:true})).rotateX(-Math.PI/2));

            // Info
            document.getElementById('infoTitle').innerText = "Vertex Construction";
            document.getElementById('proofAngle').innerText = (n*60) + "°";
            document.getElementById('proofHeight').innerText = h.toFixed(3);
            const statEl = document.getElementById('proofStatus');
            if(n===6) { statEl.innerText = "FLAT (360°)"; statEl.style.color = "red"; }
            else { statEl.innerText = "VALID (Vol > 0)"; statEl.style.color = "#0f0"; }
        }

        function drawAxes(axes) {
            const shape = state.shape;
            axes.forEach(a => {
                let color = 0x00ffff; // 2-fold
                if(shape === 'cube') {
                    if(a.type === 'face') color = 0xffff00; // 4-fold
                    if(a.type === 'vertex') color = 0xff00ff; // 3-fold
                } else if(shape === 'octahedron') {
                    if(a.type === 'vertex') color = 0xffff00;
                    if(a.type === 'face') color = 0xff00ff;
                } else if(shape === 'dodecahedron') {
                    if(a.type === 'face') color = 0x00ff00; // 5-fold
                    if(a.type === 'vertex') color = 0xff00ff;
                } else if(shape === 'icosahedron') {
                    if(a.type === 'vertex') color = 0x00ff00;
                    if(a.type === 'face') color = 0xff00ff;
                } else if(shape === 'tetrahedron') {
                    if(a.type !== 'edge') color = 0xff00ff; // 3-fold
                }

                const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([a.vec.clone().multiplyScalar(3.5), a.vec.clone().multiplyScalar(-3.5)]), new THREE.LineBasicMaterial({color, opacity:0.5, transparent:true}));
                staticAxesGroup.add(line);
            });
            document.getElementById('valAxes').innerText = axes.length;
        }

        function setupOps(geo, axes) {
            // Clone for Ghost
            const ghostGeo = geo.clone();
            const ghostMesh = new THREE.Mesh(ghostGeo, matGhost);
            const ghostEdges = new THREE.LineSegments(new THREE.EdgesGeometry(ghostGeo), matEdge);
            const ghostVerts = new THREE.Points(new THREE.BufferGeometry().setFromPoints(getUniqueVertices(geo)), matGhostVert);
            ghostGroup.add(ghostMesh);
            ghostGroup.add(ghostEdges);
            ghostGroup.add(ghostVerts);

            // Populate UI
            populateAxisUI(axes);
            populatePlaneUI(geo, axes);
        }

        function populateAxisUI(axes) {
            const sel = document.getElementById('rotAxisSelect');
            sel.innerHTML = '';
            // Categorize
            const map = { 2: [], 3: [], 4: [], 5: [] };
            const shape = state.shape;
            
            axes.forEach((a, idx) => {
                let order = 2;
                if(shape === 'cube') { if(a.type==='face') order=4; if(a.type==='vertex') order=3; }
                else if(shape === 'octahedron') { if(a.type==='vertex') order=4; if(a.type==='face') order=3; }
                else if(shape === 'dodecahedron') { if(a.type==='face') order=5; if(a.type==='vertex') order=3; }
                else if(shape === 'icosahedron') { if(a.type==='vertex') order=5; if(a.type==='face') order=3; }
                else if(shape === 'tetrahedron') { if(a.type!=='edge') order=3; }
                
                if(map[order]) map[order].push({vec: a.vec, idx});
            });

            // Add to Dropdown
            Object.keys(map).sort().forEach(order => {
                if(map[order].length > 0) {
                    const grp = document.createElement('optgroup');
                    grp.label = `${order}-fold Axis`;
                    map[order].forEach(item => {
                        const opt = document.createElement('option');
                        opt.value = item.idx;
                        opt.innerText = `Axis #${item.idx+1}`;
                        // Store vector
                        opt.dataset.x = item.vec.x;
                        opt.dataset.y = item.vec.y;
                        opt.dataset.z = item.vec.z;
                        opt.dataset.order = order;
                        grp.appendChild(opt);
                    });
                    sel.appendChild(grp);
                }
            });
            // Set default
            if(sel.options.length > 0) {
                sel.selectedIndex = 0;
                updateRotAxis();
            }
        }

        function populatePlaneUI(geo, axes) {
            const sel = document.getElementById('refPlaneSelect');
            sel.innerHTML = '';
            const planes = getSymmetryPlanes(geo, axes);
            
            planes.forEach((p, idx) => {
                const opt = document.createElement('option');
                opt.value = idx;
                opt.innerText = `${p.label} #${idx+1}`;
                opt.dataset.x = p.vec.x;
                opt.dataset.y = p.vec.y;
                opt.dataset.z = p.vec.z;
                sel.appendChild(opt);
            });
            if(sel.options.length > 0) {
                sel.selectedIndex = 0;
                updateRefPlane();
            }
        }

        // --- Animation / Update Loop Helpers ---
        function updateRotAxis() {
            const sel = document.getElementById('rotAxisSelect');
            if(sel.selectedIndex < 0) return;
            const opt = sel.options[sel.selectedIndex];
            state.rotAxis = new THREE.Vector3(parseFloat(opt.dataset.x), parseFloat(opt.dataset.y), parseFloat(opt.dataset.z));
            state.rotOrder = parseInt(opt.dataset.order);
            
            // Draw Ring
            rotationArc.clear();
            const ring = new THREE.RingGeometry(2, 2.05, 64);
            const mesh = new THREE.Mesh(ring, new THREE.MeshBasicMaterial({color: 0xffff00, side: THREE.DoubleSide, transparent:true, opacity:0.5}));
            mesh.lookAt(state.rotAxis);
            rotationArc.add(mesh);
            document.getElementById('op-description').innerHTML = `<strong>Rotation (C<sub>${state.rotOrder}</sub>)</strong><br>Axis: (${state.rotAxis.x.toFixed(1)}, ${state.rotAxis.y.toFixed(1)}, ${state.rotAxis.z.toFixed(1)})<br>Rotating the solid ${state.rotOrder} times returns it to identity (360°).`;
        }

        function updateRefPlane() {
            const sel = document.getElementById('refPlaneSelect');
            if(sel.selectedIndex < 0) return;
            const opt = sel.options[sel.selectedIndex];
            state.refPlaneNormal = new THREE.Vector3(parseFloat(opt.dataset.x), parseFloat(opt.dataset.y), parseFloat(opt.dataset.z)).normalize();
            
            // Orient Plane
            mirrorPlane.lookAt(state.refPlaneNormal);
            mirrorPlane.material.opacity = 0.2;
            document.getElementById('op-description').innerHTML = `<strong>Reflection (&sigma;)</strong><br>Plane Normal: (${state.refPlaneNormal.x.toFixed(1)}, ${state.refPlaneNormal.y.toFixed(1)}, ${state.refPlaneNormal.z.toFixed(1)})<br>The ghost reflects across this plane.`;
        }

        function animateOps() {
            if(state.mode !== 'ops') return;

            // 1. Rotation
            if(state.opType === 'rotate') {
                const rad = THREE.MathUtils.degToRad(state.rotAngle);
                const axis = state.rotAxis;
                // Rotate Main Group (Visual feedback of action)
                mainGroup.rotation.set(0,0,0); // Reset then apply
                mainGroup.setRotationFromAxisAngle(axis, rad);
                
                // Ghost rotates with it to show position?
                // Or Ghost shows the discrete steps? Let's make ghost follow main for now to show "result" of continuous rotation
                ghostGroup.rotation.set(0,0,0);
                ghostGroup.setRotationFromAxisAngle(axis, rad);
            } else {
                // Reset rotations
                mainGroup.rotation.set(0,0,0);
                ghostGroup.rotation.set(0,0,0);
            }

            // 2. Reflection
            if(state.opType === 'reflect') {
                const t = state.refProgress / 100;
                const normal = state.refPlaneNormal;
                
                // Start: Original Pos
                // End: Reflected Pos = Pos - 2 * (Pos dot N) * N
                // Since centered at origin, Reflected Pos is -Pos relative to plane? 
                // Actually for origin-centered objects, Reflection is simple inversion across the plane normal?
                // Yes. If plane is X, reflection is X -> -X.
                
                // We want to slide the ghost from Original (0) to Reflected (1)
                // Ghost Position = Lerp(Original, Reflected, t)
                // Reflected Vector = v - 2*(v.n)*n
                
                // Apply transform to Ghost
                const scale = new THREE.Vector3(1,1,1);
                scale.applyAxisAngle(normal, Math.PI * t); // This isn't reflection.
                
                // Correct Reflection Matrix
                // M = I - 2 * n * n^T
                const x = normal.x, y = normal.y, z = normal.z;
                // Full reflection matrix
                const m = new THREE.Matrix4().set(
                    1-2*x*x, -2*x*y, -2*x*z, 0,
                    -2*y*x, 1-2*y*y, -2*y*z, 0,
                    -2*z*x, -2*z*y, 1-2*z*z, 0,
                    0, 0, 0, 1
                );
                
                // We can't easily "lerp" a rotation/reflection in 3D space without issues.
                // Hack: Lerp the vertices? Too slow.
                // Better: Lerp the scale/position?
                // Actually, just setting the ghost to the reflected state is best.
                // The slider can control "Transparency" or "Phase".
                // Let's make the slider control the "Ghost Opacity" and "Ghost Translation" through the plane.
                
                // Translation approach: 
                // Ghost moves from Original (0) to Reflected Position (R).
                // Visually: Ghost slides *through* the mirror.
                
                // Construct Reflected Matrix
                ghostGroup.matrix.copy(m);
                ghostGroup.matrixAutoUpdate = false;
                
                // Interpolate between Identity and M? No, reflections are discontinuous.
                // Let's just show the Ghost appearing and moving? 
                // Let's use the slider to interpolate the position of vertices (BufferAttribute).
                // Efficient way: Scale. 
                // If Normal is X, reflection is -X.
                // Scale x from 1 to -1.
                
                // Use uniform scaling trick:
                // If normal is (1,0,0), we scale x from 1 to -1.
                // We need a basis change.
                
                // Simple approach for demo: 
                // Ghost at t=0 is at pos (invisible or overlapped).
                // Ghost at t=1 is at reflected pos.
                // Ghost moves linearly? No, that detaches it.
                // Let's simply fade it in and apply the reflection matrix.
                ghostGroup.visible = true;
                ghostGroup.matrix.copy(m); // Apply full reflection
                matGhost.opacity = t * 0.5; // Fade in as it "goes through"
                matEdge.opacity = t * 0.4;
                matGhostVert.opacity = t * 0.8;
            } else if (state.opType !== 'rotate') {
                 ghostGroup.matrixAutoUpdate = true;
            }

            // 3. Inversion
            if(state.opType === 'invert') {
                const t = state.invProgress / 100;
                // Inversion maps (x,y,z) -> (-x,-y,-z).
                // This is scaling by -1.
                const s = 1 - (2 * t); // 1 -> -1
                ghostGroup.scale.set(s, s, s);
                matGhost.opacity = 0.5;
            } else if (state.opType !== 'rotate') {
                ghostGroup.scale.set(1,1,1);
            }
        }

        // --- Event Handling ---
        // Tabs
        document.querySelectorAll('.mode-tab').forEach(t => {
            t.addEventListener('click', (e) => {
                document.querySelectorAll('.mode-tab').forEach(x => x.classList.remove('active'));
                e.target.classList.add('active');
                
                // Switch Panels
                document.querySelectorAll('.control-panel').forEach(p => p.classList.remove('active'));
                document.getElementById('panel-'+e.target.dataset.target).classList.add('active');
                
                document.querySelectorAll('#info .control-panel').forEach(p => p.classList.remove('active'));
                document.getElementById('info-'+e.target.dataset.target).classList.add('active');

                state.mode = e.target.dataset.target;
                state.autoRotate = (state.mode === 'solid');
                document.getElementById('autoRotate').checked = state.autoRotate;
                updateScene();
            });
        });

        // Solids
        document.getElementById('shapeSelect').addEventListener('change', (e) => { state.shape = e.target.value; updateScene(); });
        document.getElementById('showFaces').addEventListener('change', (e) => { state.faces = e.target.checked; updateScene(); });
        document.getElementById('showWireframe').addEventListener('change', (e) => { state.wireframe = e.target.checked; updateScene(); });
        document.getElementById('showVertices').addEventListener('change', (e) => { state.vertices = e.target.checked; updateScene(); });
        document.getElementById('showAxes').addEventListener('change', (e) => { state.axes = e.target.checked; updateScene(); });
        document.getElementById('autoRotate').addEventListener('change', (e) => { state.autoRotate = e.target.checked; });

        // Proof
        document.getElementById('proofSlider').addEventListener('input', (e) => { 
            state.proofN = parseInt(e.target.value); 
            document.getElementById('proofVal').innerText = state.proofN;
            updateScene(); 
        });
        window.resetProof = () => { document.getElementById('proofSlider').value = 3; state.proofN = 3; document.getElementById('proofVal').innerText = 3; updateScene(); };

        // Ops
        document.getElementById('opSelect').addEventListener('change', (e) => {
            state.opType = e.target.value;
            document.getElementById('ctrl-rotate').style.display = (state.opType === 'rotate') ? 'block' : 'none';
            document.getElementById('ctrl-reflect').style.display = (state.opType === 'reflect') ? 'block' : 'none';
            document.getElementById('ctrl-invert').style.display = (state.opType === 'invert') ? 'block' : 'none';
            
            // Reset visuals
            mainGroup.rotation.set(0,0,0);
            ghostGroup.rotation.set(0,0,0);
            ghostGroup.scale.set(1,1,1);
        });

        document.getElementById('rotAxisSelect').addEventListener('change', updateRotAxis);
        document.getElementById('rotAngle').addEventListener('input', (e) => { 
            state.rotAngle = parseInt(e.target.value); 
            document.getElementById('rotAngleVal').innerText = state.rotAngle + "°";
        });
        
        // Auto Rotate Animation for Ops
        let animatingRot = false;
        document.getElementById('animRotateBtn').addEventListener('click', () => {
            if(animatingRot) return;
            animatingRot = true;
            const start = performance.now();
            const dur = 2000;
            
            function loop(now) {
                const elapsed = now - start;
                const p = Math.min(elapsed / dur, 1);
                state.rotAngle = Math.floor(p * 360);
                document.getElementById('rotAngle').value = state.rotAngle;
                document.getElementById('rotAngleVal').innerText = state.rotAngle + "°";
                
                if(p < 1) requestAnimationFrame(loop);
                else animatingRot = false;
            }
            requestAnimationFrame(loop);
        });

        document.getElementById('refPlaneSelect').addEventListener('change', updateRefPlane);
        document.getElementById('refProgress').addEventListener('input', (e) => { 
            state.refProgress = parseInt(e.target.value); 
            document.getElementById('refProgressVal').innerText = state.refProgress + "%";
        });

        document.getElementById('invProgress').addEventListener('input', (e) => { 
            state.invProgress = parseInt(e.target.value); 
            document.getElementById('invProgressVal').innerText = state.invProgress + "%";
        });

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            if(state.mode === 'solid' && state.autoRotate) {
                scene.rotation.y += 0.005;
                scene.rotation.x += 0.002;
            }
            animateOps();
            controls.update();
            renderer.render(scene, camera);
        }

        // Init
        updateScene();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
